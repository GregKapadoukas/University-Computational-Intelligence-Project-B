%! TeX program = lualatex
\documentclass[12pt,a4paper]{article}

\usepackage[nil]{babel}
\usepackage{unicode-math}
\usepackage[svgnames]{xcolor}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{parskip}
\usepackage{xurl}
\usepackage{hyperref}
\usepackage[font=small,labelfont=bf,justification=centering]{caption}

\babelprovide[import=el, main, onchar=ids fonts]{greek} % can also do import=el-polyton
\babelprovide[import, onchar=ids fonts]{english}

\babelfont{rm}
          [Language=Default]{Liberation Sans}
\babelfont[english]{rm}
          [Language=Default]{Liberation Sans}
\babelfont{sf}
          [Language=Default]{Liberation Sans}
\babelfont{tt}
          [Language=Default]{Liberation Sans}

\renewcommand{\thesubsection}{\thesection.\alph{subsection}}
\setlength{\emergencystretch}{3em}

%Enter Title Here
\title{Εργασία Υπολογιστική Νοημοσύνη\\Μέρος Β}
\author{Γρηγόρης Καπαδούκας (ΑΜ: 1072484)}

\begin{document}
\maketitle

\setcounter{section}{-1}
\section{Περιβάλλον Εργασίας - Σύνδεσμος GitHub με Κώδικα}
Για την διεκπεραίωση αυτής της εργασίας έχω επιλέξει να χρησιμοποιήσω γλώσσα προγραμματισμού Python μαζί τις βιβλιοθήκες PyGAD για την υλοποίηση του γενετικού αλγορίθμου και TensorFlow (κυρίως το API της, το Keras) για τον σχεδιασμό και την εκπαίδευση του νευρωνικού δικτύου από το μέρος Α. Επίσης χρησιμοποιώ Pandas, NumPy, SciPy, Matplotlib και Scikit-Learn με σκοπό τον χειρισμό του CSV αρχείου, της προεπεξεργασίας και άλλων μαθηματικών διαδικασιών.

Ο κώδικας που γράφτηκε για την εργασία βρίσκεται στο repository στον παρακάτω σύνδεσμο:

\textcolor{blue}{\href{https://github.com/GregKapadoukas/University-Computational-Intelligence-Project-B}{https://github.com/GregKapadoukas/University-Computational-Intelligenc\\e-Project-B}}

Στο repository αυτό συμπεριλαμβάνω και το αρχείο 'environment.yml' το οποίο μπορεί να χρησιμοποιηθεί με χρήση του εργαλείου conda για να δημιουργηθεί πανομοιότυπο Python virtual environment με αυτό που χρησιμοποίησα για τη συγγραφή και εκτέλεση του κώδικα. Βέβαια για χρήση της βιβλιοθήκης TensorFlow απαιτούνται επιπλέον configuration βήματα, που αναλύονται στην εξής σελίδα:
\textcolor{blue}{\href{https://www.tensorflow.org/install/pip}{https://www.tensorflow.org/install/pip}}

\section{Σχεδιασμός Γενετικού Αλγόριθμου}

\subsection{Κωδικοποίηση}

Παρατηρώντας τα δεδομένα του dataset βλέπουμε ότι για οι αισθητήρες είναι συνολικά 4, και τα δεδομένα για κάθε αισθητήρα είναι 3 σε κάθε περίπτωση, δίνοντας συνολικά 12 πραγματικές τιμές στο εύρος [-702, 533] (υποθέτοντας πως οι αισθητήρες παράγουν τιμές στο ίδιο εύρος και πως έχουν παρατηρηθεί τα άκρα των πιθανών τιμών στις μετρήσεις του dataset. Στον κώδικα χρησιμοποιώντας τη συνάρτηση .describe() του Pandas εμφανίζουμε τη μέγιστη και ελάχιστη τιμή για κάθε αισθητήρα που παρατηρήθηκε στο dataset).

Λόγω του συνδυασμού του μεγάλου πλήθους τιμών που χρησιμοποιούνται για την αναπαράσταση της κλάσης κίνησης και του μεγάλου εύρους στο οποίο ανήκουν οι τιμές αυτές, αποφάσισα να χρησιμοποιήσω float-valued encoding, σε συνδυασμό με MinMax scaling στο εύρος [0,1].

Άρα η λύση που προσεγγίζουμε καθώς και κάθε χρωμόσωμα, θα αποτελούνται από ένα πίνακα πραγματικών αριθμών στο εύρος [0,1] μεγέθους 12. Εννοείται πως όταν βρεθεί η βέλτιστη λύση θα κάνουμε inverse MinMax scaling ώστε να επαναφερθούν οι τιμές στο εύρος [-702, 533]. 

\subsection{Πλεονάζουσες Τιμές}

Αρχικά αναφέρω ότι λόγω της χρήσης του float-valued encoding υπάρχει η πιθανότητα να προκύψουν πλεονάζοντες τιμές, δηλαδή τιμές εκτός του εύρους των τιμών των αισθητήρων. Μάλιστα λόγω της χρήσης του MinMax scaling που αναφέρθηκε, το εύρος πλέον στο οποίο πρέπει να περιέχονται όλες οι τιμές των γονιδίων σε κάθε χρωμόσωμα που παράγει ο γενετικός αλγόριθμος είναι το [0,1], στο οποίο με μετέπειτα χρήση inverse scaling θα οδηγήσει στα μη κανονικοποιημένα αποτελέσματα στο εύρος των τιμών του αισθητήρων, ώστε να γίνει η σύγκριση με τους μέσους όρους των τιμών των αισθητήρων για την κλάση 'sitting' από τα δεδομένα του dataset.

Με σκοπό να αποφύγουμε τις πλεονάζουσες τιμές αρκεί να ορίσουμε minimum bound ίσο με 0 και maximum bound ίσο με 1 για τις τιμές που παράγει ο γενετικός αλγόριθμος, με σκοπό αν μετά από μετάλλαξη να παραχθεί τιμή μικρότερη του 0, αυτή να αντικατασταθεί με 0 και αντίστοιχα αν παραχθεί τιμή μεγαλύτερη του 1, αυτή να αντικατασταθεί με 1. 

\subsection{Αρχικός Πληθυσμός}

Για τη δημιουργία του αρχικού πληθυσμού δοκίμασα δύο προσεγγίσεις: 

\begin{itemize}
    \item \textbf{Τυχαία Αρχικοποίηση:} Η πρώτη προσέγγιση είναι να χρησιμοποιήσω τυχαίες τιμές που προέρχονται από ομοιόμορφη κατανομή με εύρος τιμών [0,1]. 

    \item \textbf{Χρήση Latin Hypercube Sampling:} Η δεύτερη προσέγγιση χρησιμοποιεί Latin Hypercube Sampling, όπου αρχικά το εύρος της κάθε τιμής για γονίδιο, δηλαδή το [0,1] σε αυτή τη περίπτωση, χωρίζεται σε όσα μέρη είναι και ο αριθμός των χρωμοσωμάτων στον αρχικό πληθυσμό. Έπειτα για κάθε χρωμόσωμα γίνεται τυχαία επιλογή για κάθε γονίδιο ένα από τα μέρη του πεδίου που προέκυψαν, και διαλέγεται μια τυχαία τιμή από ομοιόμορφη κατανομή στο εύρος αυτό. Η διαδικασία αυτή γίνεται με τρόπο ώστε κάθε μέρος του χωρισμένου πεδίου ορισμού να επιλεχθεί μια φορά για το γονίδιο αυτό στο σύνολο του πληθυσμού.
\end{itemize}

Θεωρητικά η προσέγγιση του Latin Hypercube Sampling είναι η καλύτερη των δύο, επειδή εξασφαλίζει ότι ο αρχικός πληθυσμός θα έχει χρωμοσώματα που θα αναπαριστούν καλύτερα όλο το εύρος πιθανών τιμών, προσθέτοντας βέβαια κάποια επιπλέον πολυπλοκότητα για την αρχικοποίηση.

Στη πράξη όμως δοκιμάζοντας και τις δύο προσεγγίσεις, η διαφορά στα αποτελέσματα για αυτό το πρόβλημα ήταν αμελητέο, αλλά επέλεξα και πάλι το Latin Hypercube Sampling για την θεωρητική ανωτερότητά του σαν προσέγγιση αρχικοποίησης αρχικού πληθυσμού.

Σημειώνω ότι λόγω του εύρους [0,1] που επιλέχθηκε, τα χρωμοσώματα του πληθυσμού είναι ήδη κανονικοποιημένα και μετά από inverse MinMax scaling θα ανήκουν στο εύρος των πιθανών τιμών που θα μπορούσαν να έχουν οι αισθητήρες στο ρομπότ.

\subsection{Υπολογισμός Ομοιότητας}

Αρχικά, με σκοπό το σχολιασμό της καταλληλότητας της ομοιότητας συνημιτόνου σε σχέση με τις άλλες μετρικές ομοιότητας, θα αναφέρω κάποια βασικά ζητήματα για τις μετρικές:

Η ευκλείδεια απόσταση και η απόσταση Manhattan, χρησιμοποιούν την δεύτερη και πρώτη νόρμα αντίστοιχα, με σκοπό να υπολογίσουν την απόσταση. Το προτέρημα της ευκλείδειας απόστασης είναι ότι για μεγαλύτερη διαφορά μεταξύ των τιμών των γονιδίων, η απόσταση γίνεται μεγαλύτερη με τετραγωνικό ρυθμό, οπότε δημιουργείται μεγαλύτερη αύξηση στη τελική απόσταση, σε σχέση με την απόσταση Manhattan, όπου η απόσταση αυξάνεται με γραμμικό ρυθμό όσο αυξάνεται η διαφορά στα γονίδια.

\begin{itemize}
    \item \textbf{Ευκλείδεια και Manhattan Αποστάσεις:} Οπότε αν ήθελα να χρησιμοποιήσω ευκλείδεια ή Manhattan απόσταση ως συνάρτηση καταλληλότητας, θα έπρεπε να αυτό να γίνεται σε μια σχέση όπου όσο μειώνεται η απόσταση κάθε φορά, τόσο να αυξάνεται η συνάρτηση καταλληλότητας, εφόσον οι γενετικοί αλγόριθμοι προσπαθούν να αυξήσουν όσο δυνατό τη συνάρτηση καταλληλότητας ενώ εγώ θέλω να ελαχιστοποιήσω την απόσταση.

    \item \textbf{Ομοιότητα Συνημιτόνου:} Η ομοιότητα συνημιτόνου από την άλλη υπολογίζει τη τιμή του συνημιτόνου της γωνίας που προκύπτουν μεταξύ των δύο διανυσμάτων από τα οποία υπολογίζεται η μετρική. Έχει εύρος πιθανών τιμών από 0 έως 1 (για μη αρνητικά διανύσματα όπως εδώ, αλλιώς από -1 έως 1 αν υπάρχουν και αρνητικά διανύσματα) και για πολλαπλάσια των διανυσμάτων που ελέγχονται δεν αλλάζει η γωνία, οπότε δεν αλλάζει και η απόσταση συνημιτόνου. Αυτή η ιδιότητα ανάλογα το πρόβλημα και τη προσέγγιση της λύσης που εφαρμόζεται, μπορεί να συμβάλλει ή να στερήσει την απόδοση της λύσης.
        
    \item \textbf{Συσχέτιση Pearson:} Η συσχέτιση Pearson υπολογίζει τη συσχέτιση μεταξύ των τιμών του πρώτου γονιδίου σε σχέση με το δεύτερο γονίδιο, δηλαδή υπολογίζει αν παρατηρώντας μια νέα τιμή για το ένα γονίδιο, με πόση ακρίβεια μπορούμε να εξάγουμε συμπεράσματα για την τιμή του δεύτερου γονιδίου. Οι τιμές της συσχέτισης Pearson έχουν εύρος από -1, δηλαδή πλήρη αρνητική συσχέτιση, έως 1, δηλαδή πλήρη θετική συσχέτιση, με τιμή 0 να δείχνει καμία συσχέτιση. Η μετρική αυτή δεν είναι τόσο χρήσιμη σε αυτή τη περίπτωση, επειδή η συσχέτιση των γονιδίων κάθε φορά του γενετικού αλγορίθμου σε σχέση με τους μέσους όρους των τιμών του αισθητήρα δεν παρουσιάζει πληροφορία για τη κλάση κίνησης του ρομπότ.
\end{itemize}

Οπότε καταλήγουμε πως η ομοιότητα συνημιτόνου αυτομάτως είναι πιο κατάλληλη από την συσχέτιση Pearson, και ταυτόχρονα έχει ευκολότερη εφαρμογή στη συνάρτηση καταλληλότητας σε σχέση με την ευκλείδεια και Manhattan απόσταση, λόγω του επιθυμητού χαρακτηριστικού να αυξάνεται όσο πιο όμοια είναι τα δύο διανύσματα. 

Ταυτόχρονα επειδή οι τιμές των αισθητήρων του dataset προέρχονται από επιταχυνσιόμετρα, είναι πολύ πιθανό οι πολλαπλάσιες τιμές να ανήκουν κάθε φορά στην ίδια κλάση, κάτι που κάνει τη χρήση της ομοιότητας συνημιτόνου ακόμα πιο επιθυμητή.

\subsection{Συνάρτηση Καταλληλότητας}

\subsubsection{}

\textbf{Σημείωση:} Όλες οι παρακάτω πράξεις έχουν γίνει με τη προϋπόθεση ότι όλα τα διανύσματα είναι θετικά, οπότε η ομοιότητα συνημιτόνου κινείται στο εύρος [0, 1], εφόσον η προσέγγιση σχεδιασμού του ΓΑ που έχω κάνει μέχρι τώρα δεν οδηγεί ποτέ σε αρνητικά διανύσματα. Αν η προσέγγιση ήταν διαφορετική και υπήρχαν αρνητικά διανύσματα, τότε οι παρακάτω πράξεις δεν θα ίσχυαν.

Η θεωρητική μέγιστη τιμή της F είναι για μέγιστη ομοιότητα συνημιτόνου μεταξύ του $v$ και $t_s$, με μηδενική ομοιότητα μεταξύ του $v$ και όλων των $t_s$. Άρα με αντικατάσταση υπολογίζω:

\begin{center}
    $F(v)_\mathrm{max} = \frac{cos(v,t_s) + c(1-\frac{1}{4}\sum_{i\neq s}cos(v,t_i))}{1+c} \implies$

    $F(v)_\mathrm{max} = \frac{1 + c(1-\frac{1}{4}\cdot0)}{1+c} \implies$

    $F(v)_\mathrm{max} = \frac{1 + c(1-0)}{1+c} \implies$

    $F(v)_\mathrm{max} = \frac{1 + c}{1+c} \implies$

    $F(v)_\mathrm{max} = 1$
\end{center}

Στη πράξη όμως, μέχρι και το πραγματικό χρωμόσωμα με τη μεγαλύτερη εξ ορισμού καταλληλότητα, δεν έχει μηδενική ομοιότητα συνημιτόνου συγκριτικά με τις άλλες μέσες τιμές για τις άλλες κλάσεις κίνησης. Οπότε η μόνη περίπτωση στη πράξη να έχουμε τιμή $F(v) = 1$ είναι για $v = s$ καθώς και $c = 0$.

Ο υπολογισμός πραγματικής ελάχιστης τιμής στη περίπτωση αυτή είναι εξαιρετικά δύσκολη διαδικασία, και μπορεί μόνο να προσεγγιστεί, οπότε θα υπολογίσω μόνο τη θεωρητική ελάχιστη τιμή, για μηδενική ομοιότητα συνημιτόνου με το $s$ και τέλεια ομοιότητα με όλα τα $t_s$ (προφανώς κάτι που δεν θα συνέβαινε ποτέ στη πράξη). Άρα με αντικατάσταση υπολογίζω:

\begin{center}
    $F(v)_\mathrm{min} = \frac{cos(v,t_s) + c(1-\frac{1}{4}\sum_{i\neq s}cos(v,t_i))}{1+c} \implies$

    $F(v)_\mathrm{min} = \frac{0 + c(1-\frac{1}{4}\cdot1)}{1+c} \implies$

    $F(v)_\mathrm{min} = \frac{\frac{3}{4}\cdot c}{1+c} \implies$

    $F(v, c = 0)_\mathrm{min} = \frac{\frac{3}{4}\cdot 0}{1+0} \implies$

    $F(v)_\mathrm{min} = 0$
\end{center}

Οπότε παρατηρούμε ότι δεν υπάρχουν αρνητικές τιμές καταλληλότητας, εφόσον το θεωρητικό ελάχιστο είναι ίσο με 0. Ο τρόπος που τις αποφύγαμε ήταν μέσω της αποφυγής αρνητικών διανυσμάτων μέσω του MinMax scaling.

\subsubsection{}

Με βάση τις προδιαγραφές της εκφώνησης, η συνάρτηση καταλληλότητας πρέπει να οδηγεί σε υψηλές τιμές όταν τα γονίδια είναι κοντά στις μέσες τιμές των αισθητήρων για τη κατάσταση κίνησης 'sitting' και ταυτόχρονα να οδηγεί σε χαμηλότερες τιμές όταν τα γονίδια είναι κοντά στις μέσες τιμές των αισθητήρων για τις άλλες καταστάσεις. Από την συνάρτηση καταλληλότητας παρατηρούμε τα εξής:

\begin{center}
    $F(v) = \frac{cos(v,t_s) + c(1-\frac{1}{4}\sum_{i\neq s}cos(v,t_i))}{1+c} \implies$

    $F(v) = \frac{cos(v,t_s) + c - c\cdot\frac{1}{4}\sum_{i\neq s}cos(v,t_i)}{1+c} \implies$

    $F(v) = \frac{cos(v,t_s) + c}{1+c} - \frac{c\cdot\frac{1}{4}\sum_{i\neq s}cos(v,t_i)}{1+c} \implies$
\end{center}

Οπότε όσο αυξάνεται το $cos(v,t_s)$, τόσο αυξάνεται το πρώτο φράγμα και το αποτέλεσμα, και όσο αυξάνονται τα $cos(v,t_i)$ τόσο αυξάνεται το δεύτερο φράγμα και μειώνεται το αποτέλεσμα. Η τιμή c ορίζει το ποσοστό συμβολής του δεύτερου φράγματος στο τελικό αποτέλεσμα.

Άρα η συνάρτηση αυτή έχει τα επιθυμητά χαρακτηριστικά και είναι κατάλληλη επιλογή για χρήση ως συνάρτηση καταλληλότητας.

\subsubsection{}

Εφόσον η τιμή της σταθεράς c παίζει το ρόλο ενός ποσοστού που συμβάλλει η ελαχιστοποίηση της ομοιότητας με τις άλλες καταστάσεις στην έξοδο της συνάρτησης καταλληλότητας σε σχέση με την μεγιστοποίηση της ομοιότητας με την κατάσταση 'sitting', θεωρώ ότι ένα κατάλληλο ποσοστό συμβολής είναι 20\%, άρα τιμή $c = 0.2$.

\subsection{Γενετικοί Τελεστές}

\subsubsection{}

Αρχικά πριν αναφέρω το τελεστή επιλογής που θα χρησιμοποιήσω, θα κάνω μια βασική περιγραφή των τριών τελεστών:

\begin{itemize}
    \item \textbf{Ρουλέτα με βάση το κόστος:} Η επιλογή με χρήση ρουλέτας με βάση το κόστος, χρησιμοποιεί τη τιμή της συνάρτησης καταλληλότητας για να ορίσει ποσοστά επιλογής κάποιου χρωμοσώματος κάθε φορά. Με αυτό το τρόπο, όλα τα χρωμοσώματα έχουν τη πιθανότητα να επιλεχθούν, αλλά τα πιο κατάλληλα έχουν μεγαλύτερη πιθανότητα, ανάλογη με το πόσο καλύτερη ήταν η τιμή της συνάρτησης καταλληλότητας για αυτά.

    \item \textbf{Με βάση τη κατάταξη:} Η επιλογή με βάση τη κατάταξη είναι παρόμοια με τη χρήση ρουλέτας με βάση το κόστος, με τη κύρια διαφορά ότι πλέον οι πιθανότητες ορίζονται για τα χρωμοσώματα με βάση τη κατάταξή τους με βάση τη τιμή της συνάρτησης καταλληλότητας. Δηλαδή τα χρωμοσώματα με μεγαλύτερη συνάρτηση καταλληλότητας είναι πιο ψηλά στη κατάταξη, οπότε έχουν μεγαλύτερη πιθανότητα να επιλεχθούν. Άρα πλέον η διαφορά στη πιθανότητα δύο διαδοχικών στη κατάταξη χρωμοσωμάτων είναι σταθερή, ασχέτως το μέγεθος της διαφοράς στη καταλληλότητα, σε αντίθεση με τη χρήση ρουλέτας με βάση το κόστος. Αυτό έχει το προτέρημα ότι μπορεί να οδηγήσει σε μεγαλύτερη εξερεύνηση του πεδίου ορισμού των πιθανών τιμών για τα γονίδια των χρωμοσωμάτων.

    \item \textbf{Τουρνουά:} Η επιλογή με βάση το τουρνουά επιλέγει τυχαία κάθε φορά ένα υποσύνολο του πληθυσμού και επιλέγει το πιο κατάλληλο κάθε φορά χρωμόσωμα από το σύνολο. Η διαδικασία αυτή γίνεται μια φορά για κάθε χρωμόσωμα που επιλέγεται. Στη περίπτωση αυτή, ενώ όλα τα χρωμοσώματα μπορούν να επιλεχθούν στο υποσύνολο, μπορεί να μην έχουν όλα τα χρωμοσώματα την ευκαιρία να επιλεχθούν, ανάλογα με το μέγεθος του τουρνουά που χρησιμοποιείται. Άρα δεν προσφέρει πάντα το ίδιο πολύ εξερεύνηση σε σχέση με άλλες μεθόδους, αλλά οδηγεί σε πολύ εύκολο, αποδοτικό και παραλληλοποιήσιμο κώδικα.
\end{itemize}

Δοκιμάζοντας και τους τρεις τελεστές στον κώδικα, παρατηρώ ότι η διαφορά στις τελικές τιμές καταλληλότητας από τα καλύτερα χρωμοσώματα μετά από το τέλος της εκτέλεσης του γενετικού αλγόριθμου δεν είναι μεγάλη για τις διαφορετικές τεχνικές. Οπότε επέλεξα να χρησιμοποιήσω τελεστή ρουλέτας με βάση το κόστος, εφόσον δίνει και τη δυνατότητα για όλα τα χρωμοσώματα να επιλεχθούν, αντιθέτως με το τελεστή τουρνουά, ταυτόχρονα όμως συγκλίνοντας γρηγορότερα στη λύση, λόγω της ανάλογης πιθανότητας με τη διαφορά της καταλληλότητας μεταξύ των χρωμοσωμάτων, αντιθέτως με την επιλογή με βάση τη κατάταξη.

Θεωρώ επίσης ότι η καλύτερη εξερεύνηση του πεδίου που προσφέρει η επιλογή με βάση τη κατάταξη δεν είναι τόσο αναγκαία σε αυτή τη περίπτωση, εφόσον στην αντιμετώπιση του περιορισμένου πεδίου εξερεύνησης συμβάλλει και η χρήση του latin hypercube sampling για τη δημιουργία του αρχικού πληθυσμού, που επέλεξα να χρησιμοποιήσω.

\subsubsection{}

Αρχικά πριν αναφέρω το τελεστή διασταύρωσης που θα χρησιμοποιήσω, θα κάνω μια βασική περιγραφή των τριών τελεστών:

\begin{itemize}
    \item \textbf{Διασταύρωση μονού σημείου:} Στη διασταύρωση μονού σημείου επιλέγεται τυχαία ένα σημείο στα χρωμοσώματα, και τα γονίδια στα δεξιά από το σημείο αυτό εναλλάσσονται μεταξύ των δύο χρωμοσωμάτων. Ο τελεστής αυτός προτιμάται σε σχέση με τους άλλους, όταν το πρόβλημα έχει μικρό βαθμό επίστασης, εφόσον λιγότερα γονίδια εναλλάσσονται συγκριτικά με τις άλλες μεθόδους, οδηγώντας σε μικρότερη διακύμανση των διαφορών των τιμών των γονιδίων που δοκιμάζονται, οπότε δεν μελετώνται σύνθετες σχέσεις μεταξύ των γονιδίων, ταυτόχρονα όμως βοηθώντας έτσι στον εντοπισμό των τιμών των γονιδίων που έχουν τη μεγαλύτερη αποτύπωση στη τελική τιμή της καταλληλότητας.
    \item \textbf{Διασταύρωση πολλαπλού σημείου:} Στη διασταύρωση πολλαπλού σημείου (συνήθως στη πράξη γίνεται δύο σημείων) επιλέγονται τυχαία πολλά σημεία στα χρωμοσώματα, και σε κάθε τμήμα εναλλάξ που προκύπτει εναλλάσσονται ή όχι ή δεν εναλλάσσονται τα γονίδια των χρωμοσωμάτων. Άρα πρακτικά έχει παρόμοια λειτουργία όπως στη διασταύρωση μονού σημείου, με τη διαφορά ότι πλέον δεν επιλέγονται ένα ή παραπάνω τμήματα για εναλλαγή, αντί για όλα τα γονίδια δεξιά από το σημείο. Αυτός ο τελεστής προτιμάται σε προβλήματα με μεγαλύτερη επίσταση, εφόσον υπάρχει μεγαλύτερη διακύμανση στις διαφορές μεταξύ των γονιδίων, με αποτέλεσμα να μπορούν να ανακαλυφθούν πολύπλοκες συσχετίσεις μεταξύ των γονιδίων που να επηρεάζουν τη τιμή της καταλληλότητας.
    \item \textbf{Ομοιόμορφη διασταύρωση:} Στη ομοιόμορφη διασταύρωση για κάθε γονίδιο του νέου χρωμοσώματος, επιλέγεται τυχαία η τιμή από έναν από τους δύο γονείς. Ο τελεστής αυτός είναι χρήσιμος σε περιπτώσεις όπου υπάρχει μεγαλύτερη διακύμανση στις τιμές των γονιδίων των χρωμοσωμάτων που φέρουν καλή τιμή καταλληλότητας, εφόσον δοκιμάζονται περισσότεροι συνδυασμοί, αλλά ταυτόχρονα υπάρχει ρίσκο να χαθούν σχέσεις μεταξύ πολλαπλών γονιδίων που έχουν βρεθεί και οδηγούν σε υψηλή καταλληλότητα.
\end{itemize}

Δοκιμάζοντας και τους τρεις τελεστές σε κώδικα, πρόσεξα ότι τα καλύτερα αποτελέσματα για το πρόβλημα αυτό παρουσιάζουν παρόμοια τιμή καταλληλότητας με παρόμοιους αριθμούς γενιών και για τους τρεις τελεστές.

Παρόλα αυτά τελικά επέλεξα να χρησιμοποιήσω διασταύρωση διπλού σημείου, εφόσον υποθέτω ότι το πρόβλημα θα έχει σχετικά υψηλή επίσταση, εφόσον συνδυασμός κάθε φορά πολλών τιμών των αισθητήρων είναι αναγκαία για να αποτυπωθεί η πληροφορία της κλάσης, άρα υποθέτω ότι υπάρχει σχετικά μεγάλη αλληλεπίδραση μεταξύ των μεταβλητών.

\subsubsection{}

Σχετικά με το τελεστή μετάλλαξης, μετά από δοκιμές πολλών τελεστών (random, swap, inversion, scramble) επέλεξα να χρησιμοποιήσω τυχαία (random) μετάλλαξη που μου έφερνε τα καλύτερα αποτελέσματα, δηλαδή για κάθε χρωμόσωμα που επιλέγεται τυχαία για να εφαρμοστεί μετάλλαξη, προστίθεται ένας τυχαίος αριθμός από το εύρος [-1, 1]. Εννοείται αν ο τελικός αριθμός καταλήξει μικρότερος του -1 ή μεγαλύτερος του 1 στρογγυλοποιείται στο 0 και 1 αντίστοιχα, εφόσον έχουμε MinMax scaling στο εύρος [0,1].

Σχετικά με τη χρήση ελιτισμού, αναφέρω αρχικά ότι είναι μια τεχνική ευρεία χρησιμοποιούμενη, η οποία περιορίζει τη διαδικασία της μετάλλαξης ώστε να μην γίνεται μετάλλαξη στο καλύτερο (ή στα καλύτερα) με βάση τη καταλληλότητα χρωμοσώματα που επιλέχθηκε για την επόμενη γενιά. Στη περίπτωση αυτή επέλεξα να χρησιμοποιήσω ελιτισμό, εφόσον χρησιμοποιώ και τυχαία μετάλλαξη και το θεωρώ ιδιαίτερα σημαντικό να μην χαθεί η πληροφορία που φέρει το καλύτερο χρωμόσωμα που έχει βρεθεί κάθε φορά.

\section{Υλοποίηση Γενετικού Αλγορίθμου}

Σχετικά με την υλοποίηση του γενετικού αλγορίθμου, αναφέρω ξανά ότι έχω χρησιμοποιήσει περιβάλλον εργασίας Python με χρήση της βιβλιοθήκης PyGAD (για το σχεδιασμό του γενετικού αλγορίθμου), Pandas, Scikit-Learn, NumPy, Scipy και Matplotlib. Επίσης ο κώδικάς μου βρίσκεται στο σύνδεσμο GitHub που έχω στην αρχή της αναφοράς αυτής.

Παρακάτω αναφέρω σύντομα τα βήματα και μερικά σχόλια της λογικής που ακολούθησα γράφοντας τον κώδικα:

\begin{enumerate}
    \item Αρχικά κάνω χρήση της βιβλιοθήκης Pandas για να διαβάσω το αρχείο του dataset σε ένα DataFrame, φιλτράροντας μόνο τις στήλες που έχουν τις τιμές των αισθητήρων και της κλάσης, και τυπώνω στατιστικές πληροφορίες για κάθε στήλη.
    \item Έπειτα κάνω το preprocessing των δεδομένων, αρχικά κάνοντας group τα δεδομένα του dataset με βάση τη κλάση και κάνοντας aggregate τα grouped δεδομένα με βάση το μέσο όρο κάθε στήλης. Άρα πλέον στη μεταβλητή 'mean\_sensor\_data' έχω τους μέσους όρους για κάθε τιμή των αισθητήρων για κάθε κλάση. Έπειτα χρησιμοποιώντας τη βιβλιοθήκη Scikit-Learn, κάνω MinMax scaling στο εύρος [0, 1] τα δεδομένα της μεταβλητής 'mean\_sensor\_data', και αποθηκεύω τα αποτελέσματα στη μεταβλητή 'normalized\_mean\_data'. Επίσης ορίζω και τη συνάρτηση 'inverseTransformAndReshape()' η οποία μετασχηματίζει αργότερα τα αποτελέσματα του γενετικού αλγόριθμου από λίστα σε ΝumPy array κατάλληλου σχήματος, ώστε να γίνει μετά inverse MinMax scaling και να επιστραφεί το αποτέλεσμα σε μη κανονικοποιημένη μορφή.
    \item Έπειτα ορίζω δύο ακόμα συναρτήσεις, αρχικά την 'fitness\_function()' η οποία ορίζει τη συνάρτηση καταλληλότητας που θα χρησιμοποιηθεί αργότερα από το γενετικό αλγόριθμο, και μετά την 'manual\_fitness\_function()' η οποία έχει ακριβώς την ίδια λειτουργικότητα, αλλά μπορεί να καλεστεί χειροκίνητα για οποιοδήποτε πίνακα εισόδου, αντίθετα με τη προηγούμενη συνάρτηση που καλείται μόνο από στιγμιότυπα της κλάσης του γενετικού αλγορίθμου.
    \item Έπειτα ορίζω μια επιπλέον συνάρτηση, την 'early stopping', η οποία εκτελείται στο τέλος κάθε γενιάς από το γενετικό αλγόριθμο, και αποθηκεύει σε πίνακα την fitness τιμή του καλύτερου χρωμοσώματος, καθώς και αποθηκεύει τον αριθμό των συνεχόμενων μερών κάθε φορά που δεν έχει υπάρξει βελτίωση στη καταλληλότητα του καλύτερου μεγαλύτερη από 1\%. Έτσι αν οι ημέρες φτάσουν 50, τότε γίνεται σηματοδότηση για τη λήξη του γενετικού αλγόριθμου.
    \item Έπειτα με χρήση της βιβλιοθήκης SciPy χρησιμοποιείται latin hypercube sampling για να οριστούν τα χρωμοσώματα της πρώτης γενιάς.
    \item Έπειτα μέσω της βιβλιοθήκης PyGAD ορίζονται τα χαρακτηριστικά και οι υπερπαράμετροι του γενετικού αλγορίθμου.
    \item Τέλος τυπώνονται τα γραφήματα και τα αποτελέσματα του γενετικού αλγορίθμου χρησιμοποιώντας τη βιβλιοθήκη Matplotlib.
    \item Για το κώδικα του τελευταίου ερωτήματος που περιέχει και το νευρωνικό δίκτυο του Μέρους Α, έχω προσθέσει στο τέλος και το κώδικα από τη προηγούμενη εργασία για τα deep neural network, προσαρμοσμένο όμως ώστε να χρησιμοποιεί μόνο εισόδους για τις στήλες των τιμών των αισθητήρων αυτή τη φορά (στο Μέρος Α χρησιμοποιούσα όλες τις στήλες). Επίσης κάνω πρόβλεψη χρησιμοποιώντας το νευρωνικό δίκτυο, με είσοδο το καλύτερο αποτέλεσμα του γενετικού αλγορίθμου και τυπώνω τη κλάση που μάντεψε, περιμένοντας η έξοδος αυτή να είναι η κλάση 'sitting'.
\end{enumerate}

\section{Αξιολόγηση και Επίδραση Παραμέτρων}

\end{document}
